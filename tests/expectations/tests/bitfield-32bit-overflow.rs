/* automatically generated by rust-bindgen */


#![allow(dead_code, non_snake_case, non_camel_case_types, non_upper_case_globals)]


#[repr(C, packed)]
#[derive(Debug, Default, Copy, Clone)]
pub struct MuchBitfield {
    pub _bitfield_1: [u8; 5usize],
}
#[test]
fn bindgen_test_layout_MuchBitfield() {
    assert_eq!(
        ::std::mem::size_of::<MuchBitfield>(),
        5usize,
        concat!("Size of: ", stringify!(MuchBitfield))
    );
    assert_eq!(
        ::std::mem::align_of::<MuchBitfield>(),
        1usize,
        concat!("Alignment of ", stringify!(MuchBitfield))
    );
}
impl MuchBitfield {
    #[inline]
    pub fn m0(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x1 as u64;
        let val = (unit_field_val & mask) >> 0usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m0(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x1 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 0usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m1(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x2 as u64;
        let val = (unit_field_val & mask) >> 1usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m1(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x2 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 1usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m2(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x4 as u64;
        let val = (unit_field_val & mask) >> 2usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m2(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x4 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 2usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m3(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x8 as u64;
        let val = (unit_field_val & mask) >> 3usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m3(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x8 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 3usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m4(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x10 as u64;
        let val = (unit_field_val & mask) >> 4usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m4(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x10 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 4usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m5(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x20 as u64;
        let val = (unit_field_val & mask) >> 5usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m5(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x20 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 5usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m6(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x40 as u64;
        let val = (unit_field_val & mask) >> 6usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m6(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x40 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 6usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m7(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x80 as u64;
        let val = (unit_field_val & mask) >> 7usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m7(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x80 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 7usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m8(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x100 as u64;
        let val = (unit_field_val & mask) >> 8usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m8(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x100 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 8usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m9(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x200 as u64;
        let val = (unit_field_val & mask) >> 9usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m9(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x200 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 9usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m10(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x400 as u64;
        let val = (unit_field_val & mask) >> 10usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m10(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x400 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 10usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m11(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x800 as u64;
        let val = (unit_field_val & mask) >> 11usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m11(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x800 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 11usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m12(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x1000 as u64;
        let val = (unit_field_val & mask) >> 12usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m12(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x1000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 12usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m13(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x2000 as u64;
        let val = (unit_field_val & mask) >> 13usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m13(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x2000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 13usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m14(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x4000 as u64;
        let val = (unit_field_val & mask) >> 14usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m14(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x4000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 14usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m15(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x8000 as u64;
        let val = (unit_field_val & mask) >> 15usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m15(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x8000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 15usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m16(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x10000 as u64;
        let val = (unit_field_val & mask) >> 16usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m16(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x10000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 16usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m17(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x20000 as u64;
        let val = (unit_field_val & mask) >> 17usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m17(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x20000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 17usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m18(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x40000 as u64;
        let val = (unit_field_val & mask) >> 18usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m18(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x40000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 18usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m19(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x80000 as u64;
        let val = (unit_field_val & mask) >> 19usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m19(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x80000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 19usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m20(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x100000 as u64;
        let val = (unit_field_val & mask) >> 20usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m20(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x100000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 20usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m21(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x200000 as u64;
        let val = (unit_field_val & mask) >> 21usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m21(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x200000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 21usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m22(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x400000 as u64;
        let val = (unit_field_val & mask) >> 22usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m22(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x400000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 22usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m23(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x800000 as u64;
        let val = (unit_field_val & mask) >> 23usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m23(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x800000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 23usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m24(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x1000000 as u64;
        let val = (unit_field_val & mask) >> 24usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m24(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x1000000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 24usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m25(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x2000000 as u64;
        let val = (unit_field_val & mask) >> 25usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m25(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x2000000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 25usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m26(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x4000000 as u64;
        let val = (unit_field_val & mask) >> 26usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m26(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x4000000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 26usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m27(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x8000000 as u64;
        let val = (unit_field_val & mask) >> 27usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m27(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x8000000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 27usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m28(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x10000000 as u64;
        let val = (unit_field_val & mask) >> 28usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m28(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x10000000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 28usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m29(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x20000000 as u64;
        let val = (unit_field_val & mask) >> 29usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m29(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x20000000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 29usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m30(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x40000000 as u64;
        let val = (unit_field_val & mask) >> 30usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m30(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x40000000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 30usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m31(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x80000000 as u64;
        let val = (unit_field_val & mask) >> 31usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m31(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x80000000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 31usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn m32(&self) -> ::std::os::raw::c_char {
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        let mask = 0x100000000 as u64;
        let val = (unit_field_val & mask) >> 32usize;
        unsafe { ::std::mem::transmute(val as u8) }
    }
    #[inline]
    pub fn set_m32(&mut self, val: ::std::os::raw::c_char) {
        let mask = 0x100000000 as u64;
        let val = val as u8 as u64;
        let mut unit_field_val: u64 = unsafe { ::std::mem::uninitialized() };
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &self._bitfield_1 as *const _ as *const u8,
                &mut unit_field_val as *mut u64 as *mut u8,
                5usize,
            )
        };
        unit_field_val &= !mask;
        unit_field_val |= (val << 32usize) & mask;
        unsafe {
            ::std::ptr::copy_nonoverlapping(
                &unit_field_val as *const _ as *const u8,
                &mut self._bitfield_1 as *mut _ as *mut u8,
                5usize,
            );
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        m0: ::std::os::raw::c_char,
        m1: ::std::os::raw::c_char,
        m2: ::std::os::raw::c_char,
        m3: ::std::os::raw::c_char,
        m4: ::std::os::raw::c_char,
        m5: ::std::os::raw::c_char,
        m6: ::std::os::raw::c_char,
        m7: ::std::os::raw::c_char,
        m8: ::std::os::raw::c_char,
        m9: ::std::os::raw::c_char,
        m10: ::std::os::raw::c_char,
        m11: ::std::os::raw::c_char,
        m12: ::std::os::raw::c_char,
        m13: ::std::os::raw::c_char,
        m14: ::std::os::raw::c_char,
        m15: ::std::os::raw::c_char,
        m16: ::std::os::raw::c_char,
        m17: ::std::os::raw::c_char,
        m18: ::std::os::raw::c_char,
        m19: ::std::os::raw::c_char,
        m20: ::std::os::raw::c_char,
        m21: ::std::os::raw::c_char,
        m22: ::std::os::raw::c_char,
        m23: ::std::os::raw::c_char,
        m24: ::std::os::raw::c_char,
        m25: ::std::os::raw::c_char,
        m26: ::std::os::raw::c_char,
        m27: ::std::os::raw::c_char,
        m28: ::std::os::raw::c_char,
        m29: ::std::os::raw::c_char,
        m30: ::std::os::raw::c_char,
        m31: ::std::os::raw::c_char,
        m32: ::std::os::raw::c_char,
    ) -> u64 {
        (((((((((((((((((((((((((((((((((0 | ((m0 as u8 as u64) << 0usize) & (0x1 as u64))
            | ((m1 as u8 as u64) << 1usize) & (0x2 as u64))
            | ((m2 as u8 as u64) << 2usize) & (0x4 as u64))
            | ((m3 as u8 as u64) << 3usize) & (0x8 as u64))
            | ((m4 as u8 as u64) << 4usize) & (0x10 as u64))
            | ((m5 as u8 as u64) << 5usize) & (0x20 as u64))
            | ((m6 as u8 as u64) << 6usize) & (0x40 as u64))
            | ((m7 as u8 as u64) << 7usize) & (0x80 as u64))
            | ((m8 as u8 as u64) << 8usize) & (0x100 as u64))
            | ((m9 as u8 as u64) << 9usize) & (0x200 as u64))
            | ((m10 as u8 as u64) << 10usize) & (0x400 as u64))
            | ((m11 as u8 as u64) << 11usize) & (0x800 as u64))
            | ((m12 as u8 as u64) << 12usize) & (0x1000 as u64))
            | ((m13 as u8 as u64) << 13usize) & (0x2000 as u64))
            | ((m14 as u8 as u64) << 14usize) & (0x4000 as u64))
            | ((m15 as u8 as u64) << 15usize) & (0x8000 as u64))
            | ((m16 as u8 as u64) << 16usize) & (0x10000 as u64))
            | ((m17 as u8 as u64) << 17usize) & (0x20000 as u64))
            | ((m18 as u8 as u64) << 18usize) & (0x40000 as u64))
            | ((m19 as u8 as u64) << 19usize) & (0x80000 as u64))
            | ((m20 as u8 as u64) << 20usize) & (0x100000 as u64))
            | ((m21 as u8 as u64) << 21usize) & (0x200000 as u64))
            | ((m22 as u8 as u64) << 22usize) & (0x400000 as u64))
            | ((m23 as u8 as u64) << 23usize) & (0x800000 as u64))
            | ((m24 as u8 as u64) << 24usize) & (0x1000000 as u64))
            | ((m25 as u8 as u64) << 25usize) & (0x2000000 as u64))
            | ((m26 as u8 as u64) << 26usize) & (0x4000000 as u64))
            | ((m27 as u8 as u64) << 27usize) & (0x8000000 as u64))
            | ((m28 as u8 as u64) << 28usize) & (0x10000000 as u64))
            | ((m29 as u8 as u64) << 29usize) & (0x20000000 as u64))
            | ((m30 as u8 as u64) << 30usize) & (0x40000000 as u64))
            | ((m31 as u8 as u64) << 31usize) & (0x80000000 as u64))
            | ((m32 as u8 as u64) << 32usize) & (0x100000000 as u64))
    }
}
